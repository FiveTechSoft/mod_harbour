/*
**  mod_harbour.c -- Apache harbour module
**  [Autogenerated via ``apxs -n harbour -g'']
**
** (c) FiveTech Software SL, 2019-2020
** Developed by Antonio Linares alinares@fivetechsoft.com
** MIT license https://github.com/FiveTechSoft/mod_harbour/blob/master/LICENSE
*/

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"
#include "util_script.h"
#include "util_mutex.h"
#include "http_log.h"
#include "http_main.h"
#include "http_request.h"
#include "apr_global_mutex.h"

#ifdef _WINDOWS_
   #include <windows.h>
#else
   #include <dlfcn.h>
#endif        

long lAPRemaining = 0;
apr_global_mutex_t * harbour_mutex;

int ap_headers_in_count( request_rec * r )
{
   return apr_table_elts( r->headers_in )->nelts;
}

int ap_headers_out_count( request_rec * r )
{
   return apr_table_elts( r->headers_out )->nelts;
}

const char * ap_headers_in_key( int iKey, request_rec * r )
{
   const apr_array_header_t * fields = apr_table_elts( r->headers_in );
   apr_table_entry_t * e = ( apr_table_entry_t * ) fields->elts;

   if( iKey >= 0 && iKey < fields->nelts )
      return e[ iKey ].key;
   else
      return "";
}

const char * ap_headers_in_val( int iKey, request_rec * r )
{
   const apr_array_header_t * fields = apr_table_elts( r->headers_in );
   apr_table_entry_t * e = ( apr_table_entry_t * ) fields->elts;

   if( iKey >= 0 && iKey < fields->nelts )
      return e[ iKey ].val;
   else
      return "";
}

const char * ap_getenv( const char * szVarName, request_rec * r )
{
   return apr_table_get( r->subprocess_env, szVarName );
}   

void ap_headers_out_set( const char * szKey, const char * szValue, request_rec * r )
{
   apr_table_set( r->headers_out, szKey, szValue );
}

void ap_set_contenttype( const char * szContentType, request_rec * r )
{
   char * szType = ( char * ) apr_pcalloc( r->pool, strlen( szContentType ) + 1 );
   
   strcpy( szType, szContentType );
   
   r->content_type = szType;
}

const char * ap_body( request_rec * r )
{
 if( ap_setup_client_block( r, REQUEST_CHUNKED_ERROR ) != OK )
    return "";

 if( ap_should_client_block( r ) )
 {
    long length = ( long ) r->remaining;
    char * rbuf = ( char * ) apr_pcalloc( r->pool, length + 1 );
    int iRead = 0, iTotal = 0;
    lAPRemaining = length;
    
    while( ( iRead = ap_get_client_block( r, rbuf + iTotal, length + 1 - iTotal ) ) < ( length + 1 - iTotal ) && iRead != 0 )
    {
       iTotal += iRead;
       iRead = 0;
    }
    return rbuf;
 }
 else
    return "";
}

#ifdef _WINDOWS_

char * GetErrorMessage( DWORD dwLastError )
{
   LPVOID lpMsgBuf;

   FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL,
                  dwLastError,
                  MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
                  ( LPTSTR ) &lpMsgBuf,
                  0,
                  NULL );

   return ( ( char * ) lpMsgBuf );
}

#endif

typedef int ( * PHB_APACHE )( void * pRequestRec, void * pAPRPuts, 
                              const char * szFileName, const char * szArgs, const char * szMethod, const char * szUserIP,
                              void * pHeadersIn, void * pHeadersOut, 
                              void * pHeadersInCount, void * pHeadersInKey, void * pHeadersInVal, 
                              void * pHeadersOutCount, void * pHeadersOutSet, void * pSetContentType, 
                              void * pApacheGetenv, void * pAPBody, long lAPRemaining );

static int harbour_handler( request_rec * r )
{
   #ifdef _WINDOWS_
      HMODULE lib_harbour = NULL;
   #else
      void * lib_harbour = NULL;
   #endif
   
   PHB_APACHE _hb_apache = NULL;
   int iResult = OK;

   if( strcmp( r->handler, "harbour" ) )
      return DECLINED;

   if( APR_SUCCESS == apr_global_mutex_lock( harbour_mutex ) )
   {
      // ap_log_error( 0, 0, 0, 0, 0, r->server, "mutex_locked" );                        

      r->content_type = "text/html";

      ap_add_cgi_vars( r );
      ap_add_common_vars( r );

      {
         // First we check the Apache environment variable LIBHARBOUR.
         char * libharbour_path = ap_getenv( "LIBHARBOUR", r );
         
         if ( libharbour_path == NULL )
         {
            // Then the compile-time macro LIBHARBOUR.
            #ifdef LIBHARBOUR
               libharbour_path = LIBHARBOUR;
            #else
               // Now we provide platform-specific defaults.
               #ifdef _WINDOWS_
                  libharbour_path = "c:\\Apache24\\htdocs\\libharbour.dll";
               #else
                  #ifdef DARWIN
                     libharbour_path = "/Library/WebServer/Documents/libharbour.3.2.0.dylib";
                  #else
                     libharbour_path = "/var/www/html/libharbour.so.3.2.0";
                  #endif
               #endif
            #endif
         }

         #ifdef _WINDOWS_
            lib_harbour = LoadLibrary( libharbour_path );
            if ( lib_harbour == NULL )
            {
               char * szErrorMessage = GetErrorMessage( GetLastError() ); 
               ap_rputs( szErrorMessage, r );
               LocalFree( ( void * ) szErrorMessage );
               return HTTP_INTERNAL_SERVER_ERROR;
            }
         #else
            lib_harbour = dlopen( libharbour_path, RTLD_LAZY );
            if (lib_harbour == NULL)
            {
               ap_rputs( dlerror(), r );
               return HTTP_INTERNAL_SERVER_ERROR;
            }
         #endif
      }

      #ifdef _WINDOWS_
         _hb_apache = ( PHB_APACHE ) GetProcAddress( lib_harbour, "hb_apache" );
      #else
         _hb_apache = dlsym( lib_harbour, "hb_apache" );
      #endif

      if( _hb_apache == NULL )
         ap_rputs( "failed to load hb_apache()", r );
      else
         iResult = _hb_apache( r, ( void * ) ap_rputs, r->filename, r->args, r->method, r->useragent_ip, 
                                 r->headers_in, r->headers_out,
                                 ( void * ) ap_headers_in_count, ( void * ) ap_headers_in_key, ( void * ) ap_headers_in_val,
                                 ( void * ) ap_headers_out_count, ( void * ) ap_headers_out_set, ( void * ) ap_set_contenttype,
                                 ( void * ) ap_getenv, ( void * ) ap_body, lAPRemaining );

      if( lib_harbour != NULL )
         #ifdef _WINDOWS_	
            FreeLibrary( lib_harbour );
         #else
            dlclose( lib_harbour );
         #endif

      apr_global_mutex_unlock( harbour_mutex );
   }

   return iResult;
}

static void harbour_child_init( apr_pool_t * p, server_rec * s )
{
   s = s;

   if( APR_SUCCESS != apr_global_mutex_create( &harbour_mutex, NULL, APR_LOCK_DEFAULT, p ) )
      exit( 1 );
   // else
   //    ap_log_error( 0, 0, 0, 0, 0, s, "harbour_child_init ok" );                        
}

static void harbour_register_hooks( apr_pool_t * p )
{
   p = p;
   ap_hook_child_init( harbour_child_init, NULL, NULL, APR_HOOK_MIDDLE );   
   ap_hook_handler( harbour_handler, NULL, NULL, APR_HOOK_MIDDLE );
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA harbour_module = {
    STANDARD20_MODULE_STUFF,
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    NULL,                  /* table of config file commands       */
    harbour_register_hooks  /* register hooks                      */
};
