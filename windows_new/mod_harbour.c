/*
**  mod_harbour.c -- Apache sample harbour module
**  [Autogenerated via ``apxs -n harbour -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory
**  by running:
**
**    $ apxs -c -i mod_harbour.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /harbour in as follows:
**
**    #   apache2.conf
**    LoadModule harbour_module modules/mod_harbour.so
**    <Location /harbour>
**    SetHandler harbour
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /harbour and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/harbour
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**
**    The sample page from mod_harbour.c
*/

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"
#include <windows.h>  

static request_rec * _r;
static apr_array_header_t * POST_pairs = NULL;

int ap_headers_in_count( void )
{
   return apr_table_elts( _r->headers_in )->nelts;
}

int ap_headers_out_count( void )
{
   return apr_table_elts( _r->headers_out )->nelts;
}

int ap_post_pairs_count( void )
{
   if( POST_pairs != NULL )
      return POST_pairs->nelts;
   else
      return 0;
}

const char * ap_headers_in_key( int iKey )
{
   const apr_array_header_t * fields = apr_table_elts( _r->headers_in );
   apr_table_entry_t * e = ( apr_table_entry_t * ) fields->elts;

   if( iKey >= 0 && iKey < fields->nelts )
      return e[ iKey ].key;
   else
      return "";
}

const char * ap_headers_in_val( int iKey )
{
   const apr_array_header_t * fields = apr_table_elts( _r->headers_in );
   apr_table_entry_t * e = ( apr_table_entry_t * ) fields->elts;

   if( iKey >= 0 && iKey < fields->nelts )
      return e[ iKey ].val;
   else
      return "";
}

const char * ap_post_pairs_key( int iKey )
{
   ap_form_pair_t * e;

   if( POST_pairs != NULL )
   {
      e = ( ap_form_pair_t * ) POST_pairs->elts;

      if( iKey >= 0 && iKey < POST_pairs->nelts )
         return e[ iKey ].name;
      else
         return "";
   }
   else
      return "";
}

const char * ap_getenv( const char * szVarName )
{
   return apr_table_get( _r->subprocess_env, szVarName );
}   

const char * ap_post_pairs_val( int iKey )
{
   ap_form_pair_t * e;

   if( POST_pairs != NULL )
   {
      e = ( ap_form_pair_t * ) POST_pairs->elts;

      if( iKey >= 0 && iKey < POST_pairs->nelts )
      {
         apr_off_t len;
         apr_size_t size; 
         char * buffer;

         apr_brigade_length( e[ iKey ].value, 1, &len );
         size = ( apr_size_t ) len;
         buffer = apr_palloc( _r->pool, size + 1 );
         apr_brigade_flatten( e[ iKey ].value, buffer, &size );
         buffer[ len ] = 0;

         return buffer;
      }
      else
         return "";
   }
   else
      return "";
}

void ap_headers_out_set( const char * szKey, const char * szValue )
{
   apr_table_set( _r->headers_out, szKey, szValue );
}

void ap_set_contenttype( const char * szContentType )
{
   _r->content_type = szContentType;
}

char * GetErrorMessage( DWORD dwLastError )
{
   LPVOID lpMsgBuf;

   FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL,
                  dwLastError,
                  MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
                  ( LPTSTR ) &lpMsgBuf,
                  0,
                  NULL );

   return ( ( char * ) lpMsgBuf );
   LocalFree( lpMsgBuf );
}

typedef int ( * PHB_APACHE )( void * pRequestRec, void * pAPRPuts, 
                              const char * szFileName, const char * szArgs, const char * szMethod, const char * szUserIP,
                              void * pHeadersIn, void * pHeadersOut, 
                              void * pHeadersInCount, void * pHeadersInKey, void * pHeadersInVal, 
                              void * pPostPairsCount, void * pPostPairsKey, void * pPostPairsVal,
                              void * pHeadersOutCount, void * pHeadersOutSet, void * pSetContentType, 
                              void * pApacheGetenv );

static int harbour_handler( request_rec * r )
{
   HMODULE lib_harbour = NULL;
   PHB_APACHE _hb_apache = NULL;
   int iResult = OK;

   if( strcmp( r->handler, "harbour" ) )
      return DECLINED;

   r->content_type = "text/html";
   _r = r;

   lib_harbour = ( HMODULE ) LoadLibrary( ap_getenv( "LIBHARBOUR" ) ); 
   if( lib_harbour == NULL )
      lib_harbour = LoadLibrary( "c:\\Apache24\\htdocs\\libharbour.dll" );

   if( lib_harbour == NULL )
   {
      char * szErrorMessage = GetErrorMessage( GetLastError() );

      ap_rputs( "c:\\Apache24\\htdocs\\libharbour.dll<br>", r ); 
      ap_rputs( szErrorMessage, r );
      LocalFree( ( void * ) szErrorMessage );
   }   
   else
   {
      ap_parse_form_data( r, NULL, &POST_pairs, -1, HUGE_STRING_LEN );
      ( ( FARPROC ) _hb_apache ) = GetProcAddress( lib_harbour, "hb_apache" );

      if( _hb_apache == NULL )
         ap_rputs( "failed to load hb_apache()", r );
      else
         iResult = _hb_apache( r, ap_rputs, r->filename, r->args, r->method, r->useragent_ip, 
                               r->headers_in, r->headers_out,
                               ( void * ) ap_headers_in_count, ( void * ) ap_headers_in_key, ( void * ) ap_headers_in_val,
                               ( void * ) ap_post_pairs_count, ( void * ) ap_post_pairs_key, ( void * ) ap_post_pairs_val, 
                               ( void * ) ap_headers_out_count, ( void * ) ap_headers_out_set, ( void * ) ap_set_contenttype,
                               ( void * ) ap_getenv );
   }

   if( lib_harbour != NULL )
      FreeLibrary( lib_harbour );

   return iResult;
}

static void harbour_register_hooks( apr_pool_t * p )
{
    ap_hook_handler( harbour_handler, NULL, NULL, APR_HOOK_MIDDLE );
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA harbour_module = {
    STANDARD20_MODULE_STUFF,
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    NULL,                  /* table of config file commands       */
    harbour_register_hooks  /* register hooks                      */
};
