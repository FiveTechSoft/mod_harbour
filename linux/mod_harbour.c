/*
**  mod_harbour.c -- Apache sample harbour module
**  [Autogenerated via ``apxs -n harbour -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory
**  by running:
**
**    $ apxs -c -i mod_harbour.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /harbour in as follows:
**
**    #   apache2.conf
**    LoadModule harbour_module modules/mod_harbour.so
**    <Location /harbour>
**    SetHandler harbour
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /harbour and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/harbour
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**
**    The sample page from mod_harbour.c
*/

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"
#include <dlfcn.h>  

static request_rec * _r;
static apr_array_header_t * POST_pairs = NULL;

int ap_headers_in_count( void )
{
   return apr_table_elts( _r->headers_in )->nelts;
}

int ap_headers_out_count( void )
{
   return apr_table_elts( _r->headers_out )->nelts;
}

int ap_post_pairs_count( void )
{
   if( POST_pairs != NULL )
      return POST_pairs->nelts;
   else
      return 0;
}

const char * ap_headers_in_key( int iKey )
{
   const apr_array_header_t * fields = apr_table_elts( _r->headers_in );
   apr_table_entry_t * e = ( apr_table_entry_t * ) fields->elts;

   if( iKey >= 0 && iKey < fields->nelts )
      return e[ iKey ].key;
   else
      return "";
}

const char * ap_headers_in_val( int iKey )
{
   const apr_array_header_t * fields = apr_table_elts( _r->headers_in );
   apr_table_entry_t * e = ( apr_table_entry_t * ) fields->elts;

   if( iKey >= 0 && iKey < fields->nelts )
      return e[ iKey ].val;
   else
      return "";
}

const char * ap_post_pairs_key( int iKey )
{
   ap_form_pair_t * e;

   if( POST_pairs != NULL )
   {
      e = ( ap_form_pair_t * ) POST_pairs->elts;

      if( iKey >= 0 && iKey < POST_pairs->nelts )
         return e[ iKey ].name;
      else
         return "";
   }
   else
      return "";
}

const char * ap_post_pairs_val( int iKey )
{
   ap_form_pair_t * e;

   if( POST_pairs != NULL )
   {
      e = ( ap_form_pair_t * ) POST_pairs->elts;

      if( iKey >= 0 && iKey < POST_pairs->nelts )
      {
         apr_off_t len;
         apr_size_t size; 
         char * buffer;

         apr_brigade_length( e[ iKey ].value, 1, &len );
         size = ( apr_size_t ) len;
         buffer = apr_palloc( _r->pool, size + 1 );
         apr_brigade_flatten( e[ iKey ].value, buffer, &size );
         buffer[ len ] = 0;

         return buffer;
      }
      else
         return "";
   }
   else
      return "";
}

void ap_headers_out_set( const char * szKey, const char * szValue )
{
   apr_table_set( _r->headers_out, szKey, szValue );
}

void ap_set_contenttype( const char * szContentType )
{
   _r->content_type = szContentType;
}

static int harbour_handler( request_rec * r )
{
   void * lib_harbour = NULL;
   int ( * _hb_apache )( void * pRequestRec, void * pAPRPuts, 
                         const char * szFileName, const char * szArgs, const char * szMethod, const char * szUserIP,
                         void * pHeadersIn, void * pHeadersOut, 
                         void * pHeadersInCount, void * pHeadersInKey, void * pHeadersInVal, 
                         void * pPostPairsCount, void * pPostPairsKey, void * pPostPairsVal,
                         void * pHeadersOutCount, void * pHeadersOutSet, void * pSetContentType ) = NULL;
   int iResult = OK;

   if( strcmp( r->handler, "harbour" ) )
      return DECLINED;

   r->content_type = "text/html";
   _r = r;

   lib_harbour = dlopen( "/var/www/html/libharbour.so.3.2.0", RTLD_LAZY );

   if( lib_harbour == NULL )
      ap_rputs( dlerror(), r );
   else
   {
      ap_parse_form_data( r, NULL, &POST_pairs, -1, HUGE_STRING_LEN );
      _hb_apache = dlsym( lib_harbour, "hb_apache" );

      if( _hb_apache == NULL )
         ap_rputs( "failed to load hb_apache()", r );
      else
         iResult = _hb_apache( r, ap_rputs, r->filename, r->args, r->method, r->useragent_ip, 
                               r->headers_in, r->headers_out,
                               ap_headers_in_count, ap_headers_in_key, ap_headers_in_val,
                               ap_post_pairs_count, ap_post_pairs_key, ap_post_pairs_val, 
                               ap_headers_out_count, ap_headers_out_set, ap_set_contenttype );
   }

   if( lib_harbour != NULL )
      dlclose( lib_harbour );

   return iResult;
}

static void harbour_register_hooks( apr_pool_t * p )
{
    ap_hook_handler( harbour_handler, NULL, NULL, APR_HOOK_MIDDLE );
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA harbour_module = {
    STANDARD20_MODULE_STUFF,
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    NULL,                  /* table of config file commands       */
    harbour_register_hooks  /* register hooks                      */
};
